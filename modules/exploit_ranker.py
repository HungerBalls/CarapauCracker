# exploit_ranker.py â€” CarapauCracker v3
from rich.table import Table
from rich.console import Console
from rich.panel import Panel
from datetime import datetime


def rank_exploits(exploits, services):
    """
    Rank exploits by potential impact and ease of exploitation
    
    Scoring criteria:
    - RCE: +100 points
    - Unauthenticated: +50 points
    - Metasploit module available: +40 points
    - Exact service/version match: +60 points
    - Public exploit available: +30 points
    - Recent (<1 year): +20 points
    - CVE exists: +25 points
    """
    
    ranked = []
    
    for exploit in exploits:
        score = 0
        tags = []
        
        title = exploit.get('title', '').lower()
        
        # Impact scoring
        if 'rce' in title or 'remote code execution' in title:
            score += 100
            tags.append('ðŸ”´ RCE')
        elif 'privilege escalation' in title or 'lpe' in title:
            score += 60
            tags.append('ðŸŸ  LPE')
        elif 'authentication bypass' in title or 'auth bypass' in title:
            score += 70
            tags.append('ðŸŸ¡ Auth Bypass')
        elif 'sql injection' in title or 'sqli' in title:
            score += 80
            tags.append('ðŸ”´ SQLi')
        elif 'dos' in title or 'denial of service' in title:
            score += 20
            tags.append('ðŸ”µ DoS')
        
        # Authentication requirements
        if 'unauthenticated' in title or 'pre-auth' in title:
            score += 50
            tags.append('âœ“ No Auth')
        
        # Exploit availability
        if exploit.get('exploit_db_id'):
            score += 30
            tags.append('ðŸ“¦ Exploit-DB')
        
        if exploit.get('metasploit_module'):
            score += 40
            tags.append('ðŸš€ MSF')
        
        if exploit.get('cve_id'):
            score += 25
            tags.append(f"ðŸ”– {exploit['cve_id']}")
        
        # Recency
        if exploit.get('year'):
            try:
                year = int(exploit['year'])
                current_year = datetime.now().year
                if year >= current_year - 1:
                    score += 20
                    tags.append('ðŸ†• Recent')
            except (ValueError, TypeError):
                # Skip if year is not a valid integer
                pass
        
        # Service matching
        for service in services:
            service_name = service['service'].lower()
            if service_name in title:
                if service.get('version') and service['version'] in title:
                    score += 60
                    tags.append('ðŸŽ¯ EXACT MATCH')
                else:
                    score += 30
                    tags.append('âœ“ Service Match')
        
        exploit['risk_score'] = score
        exploit['tags'] = tags
        ranked.append(exploit)
    
    # Sort by score (highest first)
    ranked.sort(key=lambda x: x['risk_score'], reverse=True)
    
    return ranked


def display_ranked_exploits(ranked_exploits):
    """Display ranked exploits in a table"""
    console = Console()
    table = Table(title="ðŸŽ¯ Ranked Exploits (Priority Order)", show_header=True)
    
    table.add_column("Rank", style="cyan", justify="center", width=6)
    table.add_column("Score", style="yellow", justify="center", width=7)
    table.add_column("Exploit", style="white", width=50)
    table.add_column("Tags", style="green", width=40)
    
    for i, exploit in enumerate(ranked_exploits[:10], 1):  # Top 10
        tags_str = " ".join(exploit['tags'][:3])  # Show top 3 tags
        title = exploit['title'][:47] + "..." if len(exploit['title']) > 50 else exploit['title']
        
        table.add_row(
            f"#{i}",
            str(exploit['risk_score']),
            title,
            tags_str
        )
    
    console.print(table)


def auto_select_exploit(ranked_exploits):
    """Automatically select the best exploit"""
    if not ranked_exploits:
        return None
    
    top = ranked_exploits[0]
    
    console = Console()
    console.print(Panel.fit(
        f"[bold yellow]ðŸŽ¯ Recommended Exploit:[/bold yellow]\n\n"
        f"[white]{top['title']}[/white]\n\n"
        f"[cyan]Score: {top['risk_score']}[/cyan]\n"
        f"[green]Tags: {', '.join(top['tags'])}[/green]",
        border_style="yellow"
    ))
    
    return top
